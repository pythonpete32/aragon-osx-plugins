{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (bool));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/counter/CounterV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {PluginUUPSUpgradeable} from \"../lib/plugin/PluginUUPSUpgradeable.sol\";\nimport {MultiplyHelper} from \"./MultiplyHelper.sol\";\nimport {IDAO} from \"../lib/interfaces/IDAO.sol\";\n\n/// @title CounterV1\n/// @author Aragon Association - 2022\n/// @notice The first version of an example plugin counting numbers.\ncontract CounterV1 is PluginUUPSUpgradeable {\n    /// @notice The ID of the permission required to call the `multiply` function.\n    bytes32 public constant MULTIPLY_PERMISSION_ID =\n        keccak256(\"MULTIPLY_PERMISSION\");\n\n    /// @notice A counter varaible.\n    uint256 public count;\n\n    /// @notice A helper contract associated with the plugin.\n    MultiplyHelper public multiplyHelper;\n\n    /// @notice Initializes the plugin.\n    /// @param _dao The contract of the associated DAO.\n    /// @param _multiplyHelper The helper contract associated with the plugin to multiply numbers.\n    /// @param _count The inital value of the counter.\n    function initialize(\n        IDAO _dao,\n        MultiplyHelper _multiplyHelper,\n        uint256 _count\n    ) external initializer {\n        __PluginUUPSUpgradeable_init(_dao);\n\n        count = _count;\n        multiplyHelper = _multiplyHelper;\n    }\n\n    /// @notice Multiplies the count with a number.\n    /// @param _a The number to multiply the coun with.\n    function multiply(uint256 _a)\n        public\n        view\n        auth(MULTIPLY_PERMISSION_ID)\n        returns (uint256)\n    {\n        return multiplyHelper.multiply(count, _a);\n    }\n\n    /// @notice Executes something on the DAO.\n    function execute() public {\n        // In order to do this, Count needs permission on the dao (EXEC_ROLE)\n        //dao.execute(...)\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[48] private __gap;\n}\n"
    },
    "contracts/counter/CounterV1PluginSetup.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\nimport {PermissionLib} from \"../lib/permission/PermissionLib.sol\";\nimport {IPluginSetup} from \"../lib/interfaces/IPluginSetup.sol\";\nimport {PluginSetup} from \"../lib/plugin/PluginSetup.sol\";\nimport {MultiplyHelper} from \"./MultiplyHelper.sol\";\nimport {CounterV1} from \"./CounterV1.sol\";\n\n/// @title CounterV1PluginSetup\n/// @author Aragon Association - 2022\n/// @notice The setup contract of the `CounterV1` plugin.\ncontract CounterV1PluginSetup is PluginSetup {\n    using Clones for address;\n\n    // For testing purposes, the below are public...\n    MultiplyHelper public multiplyHelperBase;\n    CounterV1 public counterBase;\n\n    address private constant NO_ORACLE = address(0);\n\n    constructor() {\n        multiplyHelperBase = new MultiplyHelper();\n        counterBase = new CounterV1();\n    }\n\n    /// @inheritdoc IPluginSetup\n    function prepareInstallationDataABI()\n        external\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        return \"(address multiplyHelper, uint num)\";\n    }\n\n    /// @inheritdoc IPluginSetup\n    function prepareInstallation(address _dao, bytes memory _data)\n        external\n        virtual\n        override\n        returns (\n            address plugin,\n            address[] memory helpers,\n            PermissionLib.ItemMultiTarget[] memory permissions\n        )\n    {\n        // Decode the parameters from the UI\n        (address _multiplyHelper, uint256 _num) = abi.decode(\n            _data,\n            (address, uint256)\n        );\n\n        address multiplyHelper = _multiplyHelper;\n\n        if (_multiplyHelper == address(0)) {\n            // deploy helper without our proxy..\n            multiplyHelper = address(\n                new ERC1967Proxy(address(multiplyHelperBase), bytes(\"\"))\n            );\n        }\n\n        bytes memory initData = abi.encodeWithSelector(\n            bytes4(keccak256(\"initialize(address,address,uint256)\")),\n            _dao,\n            multiplyHelper,\n            _num\n        );\n\n        permissions = new PermissionLib.ItemMultiTarget[](\n            _multiplyHelper == address(0) ? 3 : 2\n        );\n        helpers = new address[](1);\n\n        // deploy\n        plugin = createERC1967Proxy(address(counterBase), initData);\n\n        // set permissions\n        permissions[0] = PermissionLib.ItemMultiTarget(\n            PermissionLib.Operation.Grant,\n            _dao,\n            plugin,\n            NO_ORACLE,\n            keccak256(\"EXECUTE_PERMISSION\")\n        );\n\n        permissions[1] = PermissionLib.ItemMultiTarget(\n            PermissionLib.Operation.Grant,\n            plugin,\n            _dao,\n            NO_ORACLE,\n            counterBase.MULTIPLY_PERMISSION_ID()\n        );\n\n        if (_multiplyHelper == address(0)) {\n            permissions[2] = PermissionLib.ItemMultiTarget(\n                PermissionLib.Operation.Grant,\n                multiplyHelper,\n                plugin,\n                NO_ORACLE,\n                multiplyHelperBase.MULTIPLY_PERMISSION_ID()\n            );\n        }\n\n        // add helpers\n        helpers[0] = multiplyHelper;\n\n        return (plugin, helpers, permissions);\n    }\n\n    /// @inheritdoc IPluginSetup\n    function prepareUninstallationDataABI()\n        external\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        return \"\";\n    }\n\n    /// @inheritdoc IPluginSetup\n    function prepareUninstallation(\n        address _dao,\n        address _plugin,\n        address[] calldata _activeHelpers,\n        bytes calldata\n    )\n        external\n        virtual\n        override\n        returns (PermissionLib.ItemMultiTarget[] memory permissions)\n    {\n        permissions = new PermissionLib.ItemMultiTarget[](\n            _activeHelpers.length != 0 ? 3 : 2\n        );\n\n        // set permissions\n        permissions[0] = PermissionLib.ItemMultiTarget(\n            PermissionLib.Operation.Revoke,\n            _dao,\n            _plugin,\n            NO_ORACLE,\n            keccak256(\"EXECUTE_PERMISSION\")\n        );\n\n        permissions[1] = PermissionLib.ItemMultiTarget(\n            PermissionLib.Operation.Revoke,\n            _plugin,\n            _dao,\n            NO_ORACLE,\n            counterBase.MULTIPLY_PERMISSION_ID()\n        );\n\n        if (_activeHelpers.length != 0) {\n            permissions[2] = PermissionLib.ItemMultiTarget(\n                PermissionLib.Operation.Revoke,\n                _activeHelpers[0],\n                _plugin,\n                NO_ORACLE,\n                multiplyHelperBase.MULTIPLY_PERMISSION_ID()\n            );\n        }\n    }\n\n    /// @inheritdoc IPluginSetup\n    function getImplementationAddress()\n        external\n        view\n        virtual\n        override\n        returns (address)\n    {\n        return address(counterBase);\n    }\n}\n"
    },
    "contracts/counter/MultiplyHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {PluginUUPSUpgradeable} from \"../lib/plugin/PluginUUPSUpgradeable.sol\";\n\n/// @title MultiplyHelper\n/// @author Aragon Association - 2022\n/// @notice A helper contract providing a multiply function for the `CounterV1` and `CounterV2` example contracts.\ncontract MultiplyHelper is PluginUUPSUpgradeable {\n    /// @notice The ID of the permission required to call the `multiply` function.\n    bytes32 public constant MULTIPLY_PERMISSION_ID =\n        keccak256(\"MULTIPLY_PERMISSION\");\n\n    /// @notice Multiplies the count with a number.\n    /// @param _a The number to multiply the coun with.\n    function multiply(uint256 _a, uint256 _b)\n        external\n        view\n        auth(MULTIPLY_PERMISSION_ID)\n        returns (uint256)\n    {\n        return _a * _b;\n    }\n}\n"
    },
    "contracts/lib/dao-authorizable/bases/DaoAuthorizableBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {_auth} from \"../../utils/auth.sol\";\nimport {IDAO} from \"../../interfaces/IDAO.sol\";\n\n/// @title DaoAuthorizableBase\n/// @author Aragon Association - 2022\n/// @notice An abstract contract providing a meta transaction compatible modifier to authorize function calls through an associated DAO.\nabstract contract DaoAuthorizableBase is Context {\n    /// @notice The associated DAO managing the permissions of inheriting contracts.\n    IDAO internal dao;\n\n    /// @notice Returns the DAO contract.\n    /// @return IDAO The DAO contract.\n    function getDAO() external view returns (IDAO) {\n        return dao;\n    }\n\n    /// @notice A modifier to be used to check permissions on a target contract via the associated DAO.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    modifier auth(bytes32 _permissionId) {\n        _auth(dao, address(this), _msgSender(), _permissionId, _msgData());\n        _;\n    }\n}\n"
    },
    "contracts/lib/dao-authorizable/bases/DaoAuthorizableBaseUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\nimport {_auth} from \"../../utils/auth.sol\";\nimport {IDAO} from \"../../interfaces/IDAO.sol\";\n\n/// @title DaoAuthorizableBase\n/// @author Aragon Association - 2022\n/// @notice An abstract contract providing a meta transaction compatible modifier for upgradeable contracts to authorize function calls through an associated DAO.\nabstract contract DaoAuthorizableBaseUpgradeable is ContextUpgradeable {\n    /// @notice The associated DAO managing the permissions of inheriting contracts.\n    IDAO internal dao;\n\n    /// @notice Returns the DAO contract.\n    /// @return IDAO The DAO contract.\n    function getDAO() external view returns (IDAO) {\n        return dao;\n    }\n\n    /// @notice A modifier to be used to check permissions on a target contract via the associated DAO.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    modifier auth(bytes32 _permissionId) {\n        _auth(dao, address(this), _msgSender(), _permissionId, _msgData());\n        _;\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/lib/dao-authorizable/DaoAuthorizable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IDAO} from \"../interfaces/IDAO.sol\";\nimport {DaoAuthorizableBase} from \"./bases/DaoAuthorizableBase.sol\";\n\n/// @title DaoAuthorizable\n/// @author Aragon Association - 2022\n/// @notice An abstract contract providing a meta transaction compatible modifier for constructable contracts instantiated via the `new` keyword to authorize function calls through an associated DAO.\nabstract contract DaoAuthorizable is DaoAuthorizableBase {\n    /// @notice Constructs the contract by setting the associated DAO.\n    /// @param _dao The associated DAO address.\n    constructor(IDAO _dao) {\n        dao = _dao;\n    }\n}\n"
    },
    "contracts/lib/dao-authorizable/DaoAuthorizableCloneable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {Initializable} from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport {IDAO} from \"../interfaces/IDAO.sol\";\nimport {DaoAuthorizableBase} from \"./bases/DaoAuthorizableBase.sol\";\n\n/// @title DaoAuthorizableCloneable\n/// @author Aragon Association - 2022\n/// @notice An abstract contract providing a meta-transaction compatible modifier for clonable contracts to authorize function calls through an associated DAO.\n/// @dev Make sure to call `__DaoAuthorizableCloneable_init` during initialization of the inheriting contract.\n///      This contract is compatible with meta transactions through OZ's `Context`.\nabstract contract DaoAuthorizableCloneable is\n    Initializable,\n    DaoAuthorizableBase\n{\n    /// @notice Initializes the contract by setting the associated DAO.\n    /// @param _dao The associated DAO address.\n    function __DaoAuthorizableCloneable_init(IDAO _dao)\n        internal\n        onlyInitializing\n    {\n        dao = _dao;\n    }\n}\n"
    },
    "contracts/lib/dao-authorizable/DaoAuthorizableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\nimport {IDAO} from \"../interfaces/IDAO.sol\";\nimport {DaoAuthorizableBaseUpgradeable} from \"./bases/DaoAuthorizableBaseUpgradeable.sol\";\n\n/// @title DaoAuthorizableUpgradeable\n/// @author Aragon Association - 2022\n/// @notice An abstract contract providing a meta-transaction compatible modifier for upgradeable contracts to authorize function calls through an associated DAO.\n/// @dev Make sure to call `__DaoAuthorizableUpgradeable_init` during initialization of the inheriting contract.\nabstract contract DaoAuthorizableUpgradeable is\n    Initializable,\n    ContextUpgradeable,\n    DaoAuthorizableBaseUpgradeable\n{\n    /// @notice Initializes the contract by setting the associated DAO.\n    /// @param _dao The associated DAO address.\n    function __DaoAuthorizableUpgradeable_init(IDAO _dao)\n        internal\n        onlyInitializing\n    {\n        dao = _dao;\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/lib/interfaces/IDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\n/// @title IDAO\n/// @author Aragon Association - 2022\n/// @notice The interface required for DAOs within the Aragon App DAO framework.\nabstract contract IDAO {\n    struct Action {\n        address to; // Address to call\n        uint256 value; // Value to be sent with the call (for example ETH if on mainnet)\n        bytes data; // Function selector + arguments\n    }\n\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\n    /// @param _where The address of the contract.\n    /// @param _who The address of a EOA or contract to give the permissions.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionOracle` registered.\n    /// @return bool Returns true if the address has permission, false if not.\n    function hasPermission(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) external view virtual returns (bool);\n\n    /// @notice Updates the DAO metadata (e.g., an IPFS hash).\n    /// @param _metadata The IPFS hash of the new metadata object.\n    function setMetadata(bytes calldata _metadata) external virtual;\n\n    /// @notice Emitted when the DAO metadata is updated.\n    /// @param metadata The IPFS hash of the new metadata object.\n    event MetadataSet(bytes metadata);\n\n    /// @notice Executes a list of actions.\n    /// @dev Runs a loop through the array of actions and executes them one by one. If one action fails, all will be reverted.\n    /// @param callId The id of the call. The definition of the value of callId is up to the calling contract and can be used, e.g., as a nonce.\n    /// @param _actions The array of actions.\n    /// @return bytes[] The array of results obtained from the executed actions in `bytes`.\n    function execute(uint256 callId, Action[] memory _actions)\n        external\n        virtual\n        returns (bytes[] memory);\n\n    /// @notice Emitted when a proposal is executed.\n    /// @param actor The address of the caller.\n    /// @param callId The id of the call.\n    /// @dev The value of callId is defined by the component/contract calling the execute function.\n    ///      A `Plugin` implementation can use it, for example, as a nonce.\n    /// @param actions Array of actions executed.\n    /// @param execResults Array with the results of the executed actions.\n    event Executed(address indexed actor, uint256 callId, Action[] actions, bytes[] execResults);\n\n    /// @notice Emitted when a standard callback is registered.\n    /// @param interfaceId The ID of the interface.\n    /// @param callbackSelector The selector of the callback function.\n    /// @param magicNumber The magic number to be registered for the callback function selector.\n    event StandardCallbackRegistered(\n        bytes4 interfaceId,\n        bytes4 callbackSelector,\n        bytes4 magicNumber\n    );\n\n    /// @notice Deposits (native) tokens to the DAO contract with a reference string.\n    /// @param _token The address of the token or address(0) in case of the native token.\n    /// @param _amount The amount of tokens to deposit.\n    /// @param _reference The reference describing the deposit reason.\n    function deposit(\n        address _token,\n        uint256 _amount,\n        string calldata _reference\n    ) external payable virtual;\n\n    /// @notice Emitted when a token deposit has been made to the DAO.\n    /// @param sender The address of the sender.\n    /// @param token The address of the deposited token.\n    /// @param amount The amount of tokens deposited.\n    /// @param _reference The reference describing the deposit reason.\n    event Deposited(\n        address indexed sender,\n        address indexed token,\n        uint256 amount,\n        string _reference\n    );\n\n    /// @notice Emitted when a native token deposit has been made to the DAO.\n    /// @dev This event is intended to be emitted in the `receive` function and is therefore bound by the gas limitations for `send`/`transfer` calls introduced by [ERC-2929](https://eips.ethereum.org/EIPS/eip-2929).\n    /// @param sender The address of the sender.\n    /// @param amount The amount of native tokens deposited.\n    event NativeTokenDeposited(address sender, uint256 amount);\n\n    /// @notice Withdraw (native) tokens from the DAO with a withdraw reference string.\n    /// @param _token The address of the token and address(0) in case of the native token.\n    /// @param _to The target address to send (native) tokens to.\n    /// @param _amount The amount of (native) tokens to withdraw.\n    /// @param _reference The reference describing the withdrawal reason.\n    function withdraw(\n        address _token,\n        address _to,\n        uint256 _amount,\n        string memory _reference\n    ) external virtual;\n\n    /// @notice Emitted when a (native) token withdrawal has been made from the DAO.\n    /// @param token The address of the withdrawn token or address(0) in case of the native token.\n    /// @param to The address of the withdrawer.\n    /// @param amount The amount of tokens withdrawn.\n    /// @param _reference The reference describing the withdrawal reason.\n    event Withdrawn(address indexed token, address indexed to, uint256 amount, string _reference);\n\n    /// @notice Setter for the trusted forwarder verifying the meta transaction.\n    /// @param _trustedForwarder The trusted forwarder address.\n    function setTrustedForwarder(address _trustedForwarder) external virtual;\n\n    /// @notice Getter for the trusted forwarder verifying the meta transaction.\n    /// @return The trusted forwarder address.\n    function getTrustedForwarder() external virtual returns (address);\n\n    /// @notice Emitted when a new TrustedForwarder is set on the DAO.\n    /// @param forwarder the new forwarder address.\n    event TrustedForwarderSet(address forwarder);\n\n    /// @notice Setter for the [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) signature validator contract.\n    /// @param _signatureValidator The address of the signature validator.\n    function setSignatureValidator(address _signatureValidator) external virtual;\n\n    /// @notice Emitted when the signature validator address is updated.\n    /// @param signatureValidator The address of the signature validator.\n    event SignatureValidatorSet(address signatureValidator);\n\n    /// @notice Checks whether a signature is valid for the provided data.\n    /// @param _hash The keccak256 hash of arbitrary length data signed on the behalf of `address(this)`.\n    /// @param _signature Signature byte array associated with _data.\n    /// @return magicValue Returns the `bytes4` magic value `0x1626ba7e` if the signature is valid.\n    function isValidSignature(bytes32 _hash, bytes memory _signature)\n        external\n        virtual\n        returns (bytes4);\n\n    /// @notice Registers an ERC standard having a callback by registering its [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID and callback function signature.\n    /// @param _interfaceId The ID of the interface.\n    /// @param _callbackSelector The selector of the callback function.\n    /// @param _magicNumber The magic number to be registered for the function signature.\n    function registerStandardCallback(\n        bytes4 _interfaceId,\n        bytes4 _callbackSelector,\n        bytes4 _magicNumber\n    ) external virtual;\n}\n"
    },
    "contracts/lib/interfaces/IPermissionOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\n/// @title IPermissionOracle\n/// @author Aragon Association - 2021\n/// @notice This interface can be implemented to support more customary permissions depending on on- or off-chain state, e.g., by querying token ownershop or a secondary oracle, respectively.\ninterface IPermissionOracle {\n    /// @notice This method is used to check if a call is permitted.\n    /// @param _where The address of the target contract.\n    /// @param _who The address (EOA or contract) for which the permission are checked.\n    /// @param _permissionId The permission identifier.\n    /// @param _data Optional data passed to the `PermissionOracle` implementation.\n    /// @return allowed Returns true if the call is permitted.\n    function isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes calldata _data\n    ) external view returns (bool allowed);\n}\n"
    },
    "contracts/lib/interfaces/IPlugin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\ninterface IPlugin {\n    enum PluginType {\n        UUPS,\n        Cloneable,\n        Constructable\n    }\n\n    /// @notice returns the plugin's type\n    function pluginType() external view returns (PluginType);\n}\n"
    },
    "contracts/lib/interfaces/IPluginRepo.sol": {
      "content": "// SPDX-License-Identifier:    MIT\n\npragma solidity 0.8.10;\n\n/// @title IPluginRepo\n/// @author Aragon Association - 2022\n/// @notice The interface required for a plugin repository.\ninterface IPluginRepo {\n    /// @notice Creates a new version with contract `_pluginSetupAddress` and content `@fromHex(_contentURI)`.\n    /// @param _semanticVersion The semantic version number for the version to be created.\n    /// @param _pluginSetupAddress The address of the plugin setup contract.\n    /// @param _contentURI External URI where the plugin metadata and subsequent resources can be fetched from\n    function createVersion(\n        uint16[3] memory _semanticVersion,\n        address _pluginSetupAddress,\n        bytes calldata _contentURI\n    ) external;\n}\n"
    },
    "contracts/lib/interfaces/IPluginSetup.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {PermissionLib} from \"../permission/PermissionLib.sol\";\n\ninterface IPluginSetup {\n    /// @notice The ABI required to decode the `bytes` data in `prepareInstallation()`.\n    /// @return The ABI in string format.\n    function prepareInstallationDataABI() external view returns (string memory);\n\n    /// @notice Prepares the installation of a plugin.\n    /// @param _dao The address of the installing DAO.\n    /// @param _data The `bytes` encoded data containing the input parameters for the installation as specified in the `prepareInstallationDataABI()` function.\n    /// @return plugin The address of the `Plugin` contract being prepared for installation.\n    /// @return helpers The address array of all helpers (contracts or EOAs) associated with the plugin after the installation.\n    /// @return permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the installing DAO.\n    function prepareInstallation(address _dao, bytes memory _data)\n        external\n        returns (\n            address plugin,\n            address[] memory helpers,\n            PermissionLib.ItemMultiTarget[] memory permissions\n        );\n\n    /// @notice The ABI required to decode the `bytes` data in `prepareUpdate()`.\n    /// @return The ABI in string format.\n    /// @dev The empty implemention is provided here so that this doesn't need to be overriden and implemented. This is relevant, for example, for the initial version of a plugin for which no update exists.\n    function prepareUpdateDataABI() external view returns (string memory);\n\n    /// @notice Prepares the update of a plugin.\n    /// @param _dao The address of the updating DAO.\n    /// @param _plugin The address of the `Plugin` contract to update from.\n    /// @param _currentHelpers The address array of all current helpers (contracts or EOAs) associated with the plugin to update from.\n    /// @param _oldVersion The semantic version of the plugin to update from.\n    /// @param _data The `bytes` encoded data containing the input parameters for the update as specified in the `prepareUpdateDataABI()` function.\n    /// @return updatedHelpers The address array of helpers (contracts or EOAs) associated with the plugin after the update.\n    /// @return initData The initialization data to be passed to upgradeable contracts when the update is applied in the `PluginSetupProcessor`.\n    /// @return permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the updating DAO.\n    /// @dev The array of `_currentHelpers` has to be specified in the same order as they were returned from previous setups preparation steps (the latest `prepareInstallation` or `prepareUpdate` step that has happend) on which this update is prepared for.\n    function prepareUpdate(\n        address _dao,\n        address _plugin,\n        address[] memory _currentHelpers,\n        uint16[3] calldata _oldVersion,\n        bytes memory _data\n    )\n        external\n        returns (\n            address[] memory updatedHelpers,\n            bytes memory initData,\n            PermissionLib.ItemMultiTarget[] memory permissions\n        );\n\n    /// @notice The ABI required to decode the `bytes` data in `prepareUninstallation()`.\n    /// @return The ABI in string format.\n    function prepareUninstallationDataABI()\n        external\n        view\n        returns (string memory);\n\n    /// @notice Prepares the uninstallation of a plugin.\n    /// @param _dao The address of the uninstalling DAO.\n    /// @param _plugin The address of the `Plugin` contract to update from.\n    /// @param _currentHelpers The address array of all current helpers (contracts or EOAs) associated with the plugin to update from.\n    /// @param _data The `bytes` encoded data containing the input parameters for the uninstalltion as specified in the `prepareUninstallationDataABI()` function.\n    /// @return permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the uninstalling DAO.\n    /// @dev The array of `_currentHelpers` has to be specified in the same order as they were returned from previous setups preparation steps (the latest `prepareInstallation` or `prepareUpdate` step that has happend) on which this update is prepared for.\n    function prepareUninstallation(\n        address _dao,\n        address _plugin,\n        address[] calldata _currentHelpers,\n        bytes calldata _data\n    ) external returns (PermissionLib.ItemMultiTarget[] memory permissions);\n\n    /// @notice Returns the plugin's base implementation.\n    /// @return address The address of the plugin implementation contract.\n    /// @dev The implementation can be instantiated via the `new` keyword, cloned via the minimal clones pattern (see [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167)), or proxied via the UUPS pattern (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    function getImplementationAddress() external view returns (address);\n}\n"
    },
    "contracts/lib/permission/PermissionLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\n/// @title PermissionLib\n/// @author Aragon Association - 2021, 2022\n/// @notice A library containing objects for permission processing.\nlibrary PermissionLib {\n    enum Operation {\n        Grant,\n        Revoke,\n        Freeze,\n        GrantWithOracle\n    }\n\n    struct ItemSingleTarget {\n        Operation operation;\n        address who;\n        bytes32 permissionId;\n    }\n\n    struct ItemMultiTarget {\n        Operation operation;\n        address where;\n        address who;\n        address oracle;\n        bytes32 permissionId;\n    }\n}\n"
    },
    "contracts/lib/permission/PermissionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../interfaces/IPermissionOracle.sol\";\nimport \"./PermissionLib.sol\";\n\n/// @title PermissionManager\n/// @author Aragon Association - 2021, 2022\n/// @notice The permission manager used in a DAO and its associated components.\ncontract PermissionManager is Initializable {\n    /// @notice The ID of the permission required to call the `grant`, `grantWithOracle`, `revoke`, `freeze`, and `bulk` function.\n    bytes32 public constant ROOT_PERMISSION_ID = keccak256(\"ROOT_PERMISSION\");\n\n    /// @notice A special address encoding permissions that are valid for any address.\n    address internal constant ANY_ADDR = address(type(uint160).max);\n\n    /// @notice A special address encoding if a permissions is not set and therefore not allowed.\n    address internal constant UNSET_FLAG = address(0);\n\n    /// @notice A special address encoding if a permission is allowed.\n    address internal constant ALLOW_FLAG = address(2);\n\n    /// @notice A mapping storing permissions as hashes (i.e., `permissionHash(where, who, permissionId)`) and their status (unset, allowed, or redirect to a `PermissionOracle`).\n    mapping(bytes32 => address) internal permissionsHashed;\n\n    /// @notice A mapping storing frozen permissions as hashes (i.e., `frozenPermissionHash(where, permissionId)`) and their status (`true` = frozen (immutable), `false` = not frozen (mutable)).\n    mapping(bytes32 => bool) internal frozenPermissionsHashed;\n\n    /// @notice Thrown if a call is unauthorized.\n    /// @param here The context in which the authorization reverted.\n    /// @param where The contract requiring the permission.\n    /// @param who The address (EOA or contract) missing the permission.\n    /// @param permissionId The permission identifier.\n    error Unauthorized(\n        address here,\n        address where,\n        address who,\n        bytes32 permissionId\n    );\n\n    /// @notice Thrown if a permission has been already granted.\n    /// @param where The address of the target contract to grant `who` permission to.\n    /// @param who The address (EOA or contract) to which the permission has already been granted.\n    /// @param permissionId The permission identifier.\n    error PermissionAlreadyGranted(\n        address where,\n        address who,\n        bytes32 permissionId\n    );\n\n    /// @notice Thrown if a permission has been already revoked.\n    /// @param where The address of the target contract to revoke `who`s permission from.\n    /// @param who The address (EOA or contract) from which the permission has already been revoked.\n    /// @param permissionId The permission identifier.\n    error PermissionAlreadyRevoked(\n        address where,\n        address who,\n        bytes32 permissionId\n    );\n\n    /// @notice Thrown if a permission is frozen.\n    /// @param where The address of the target contract for which the permission is frozen.\n    /// @param permissionId The permission identifier.\n    error PermissionFrozen(address where, bytes32 permissionId);\n\n    /// @notice Thrown if a Root permission is set on ANY_ADDR.\n    error RootPermissionForAnyAddressDisallowed();\n\n    /// @notice Thrown if a freeze happens on ANY_ADDR.\n    error FreezeOnAnyAddressDisallowed();\n\n    // Events\n\n    /// @notice Emitted when a permission `permission` is granted in the context `here` to the address `who` for the contract `where`.\n    /// @param permissionId The permission identifier.\n    /// @param here The address of the context in which the permission is granted.\n    /// @param who The address (EOA or contract) receiving the permission.\n    /// @param where The address of the target contract for which `who` receives permission.\n    /// @param oracle The address `ALLOW_FLAG` for regular permissions or, alternatively, the `PermissionOracle` to be used.\n    event Granted(\n        bytes32 indexed permissionId,\n        address indexed here,\n        address indexed who,\n        address where,\n        IPermissionOracle oracle\n    );\n\n    /// @notice Emitted when a permission `permission` is revoked in the context `here` from the address `who` for the contract `where`.\n    /// @param permissionId The permission identifier.\n    /// @param here The address of the context in which the permission is revoked.\n    /// @param who The address (EOA or contract) losing the permission.\n    /// @param where The address of the target contract for which `who` loses permission\n    event Revoked(\n        bytes32 indexed permissionId,\n        address indexed here,\n        address indexed who,\n        address where\n    );\n\n    /// @notice Emitted when a `permission` is made frozen to the address `here` by the contract `where`.\n    /// @param permissionId The permission identifier.\n    /// @param here The address of the context in which the permission is frozen.\n    /// @param where The address of the target contract for which the permission is frozen.\n    event Frozen(\n        bytes32 indexed permissionId,\n        address indexed here,\n        address where\n    );\n\n    /// @notice A modifier to be used to check permissions on a target contract.\n    /// @param _where The address of the target contract for which the permission is required.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    modifier auth(address _where, bytes32 _permissionId) {\n        _auth(_where, _permissionId);\n        _;\n    }\n\n    /// @notice Initialization method to set the initial owner of the permission manager.\n    /// @dev The initial owner is granted the `ROOT_PERMISSION_ID` permission.\n    /// @param _initialOwner The initial owner of the permission manager.\n    function __PermissionManager_init(address _initialOwner)\n        internal\n        onlyInitializing\n    {\n        _initializePermissionManager(_initialOwner);\n    }\n\n    /// @notice Grants permission to an address to call methods in a contract guarded by an auth modifier with the specified permission identifier.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\n    /// @param _where The address of the target contract for which `who` recieves permission.\n    /// @param _who The address (EOA or contract) receiving the permission.\n    /// @param _permissionId The permission identifier.\n    function grant(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) external auth(_where, ROOT_PERMISSION_ID) {\n        _grant(_where, _who, _permissionId);\n    }\n\n    /// @notice Grants permission to an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier if the referenced oracle permits it.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission\n    /// @param _where The address of the target contract for which `who` recieves permission.\n    /// @param _who The address (EOA or contract) receiving the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _oracle The `PermissionOracle` that will be asked for authorization on calls connected to the specified permission identifier.\n    function grantWithOracle(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        IPermissionOracle _oracle\n    ) external auth(_where, ROOT_PERMISSION_ID) {\n        _grantWithOracle(_where, _who, _permissionId, _oracle);\n    }\n\n    /// @notice Revokes permission from an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\n    /// @param _where The address of the target contract for which `who` loses permission.\n    /// @param _who The address (EOA or contract) losing the permission.\n    /// @param _permissionId The permission identifier.\n    function revoke(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) external auth(_where, ROOT_PERMISSION_ID) {\n        _revoke(_where, _who, _permissionId);\n    }\n\n    /// @notice Freezes the current permission settings of a target contract. This is a permanent operation and permissions on the specified contract with the specified permission identifier can never be granted or revoked again.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\n    /// @param _where The address of the target contract for which the permission are frozen.\n    /// @param _permissionId The permission identifier.\n    function freeze(address _where, bytes32 _permissionId)\n        external\n        auth(_where, ROOT_PERMISSION_ID)\n    {\n        _freeze(_where, _permissionId);\n    }\n\n    /// @notice Processes bulk items on the permission manager.\n    /// @dev Requires the `ROOT_PERMISSION_ID` permission.\n    /// @param _where The address of the contract.\n    /// @param items The array of bulk items to process.\n    function bulkOnSingleTarget(\n        address _where,\n        PermissionLib.ItemSingleTarget[] calldata items\n    ) external auth(_where, ROOT_PERMISSION_ID) {\n        for (uint256 i = 0; i < items.length; ) {\n            PermissionLib.ItemSingleTarget memory item = items[i];\n\n            if (item.operation == PermissionLib.Operation.Grant) {\n                _grant(_where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.Revoke) {\n                _revoke(_where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.Freeze) {\n                _freeze(_where, item.permissionId);\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @notice Processes bulk items on the permission manager.\n    /// @dev Requires that msg.sender has each permissionId on the where.\n    /// @param items The array of bulk items to process.\n    function bulkOnMultiTarget(PermissionLib.ItemMultiTarget[] calldata items)\n        external\n    {\n        for (uint256 i = 0; i < items.length; ) {\n            PermissionLib.ItemMultiTarget memory item = items[i];\n\n            // TODO: Optimize\n            _auth(item.where, ROOT_PERMISSION_ID);\n\n            if (item.operation == PermissionLib.Operation.Grant) {\n                _grant(item.where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.Revoke) {\n                _revoke(item.where, item.who, item.permissionId);\n            } else if (item.operation == PermissionLib.Operation.Freeze) {\n                _freeze(item.where, item.permissionId);\n            } else if (\n                item.operation == PermissionLib.Operation.GrantWithOracle\n            ) {\n                _grantWithOracle(\n                    item.where,\n                    item.who,\n                    item.permissionId,\n                    IPermissionOracle(item.oracle)\n                );\n            }\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\n    /// @param _where The address of the target contract for which `who` recieves permission.\n    /// @param _who The address (EOA or contract) for which the permission is checked.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionOracle` registered.\n    /// @return bool Returns true if `who` has the permissions on the target contract via the specified permission identifier.\n    function isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) public view returns (bool) {\n        return\n            _isGranted(_where, _who, _permissionId, _data) || // check if _who has permission for _permissionId on _where\n            _isGranted(_where, ANY_ADDR, _permissionId, _data) || // check if anyone has permission for _permissionId on _where\n            _isGranted(ANY_ADDR, _who, _permissionId, _data); // check if _who has permission for _permissionId on any contract\n    }\n\n    /// @notice This method is used to check if permissions for a given permission identifier on a contract are frozen.\n    /// @param _where The address of the target contract for which `who` recieves permission.\n    /// @param _permissionId The permission identifier.\n    /// @return bool Returns true if the permission identifier is frozen for the contract address.\n    function isFrozen(address _where, bytes32 _permissionId)\n        public\n        view\n        returns (bool)\n    {\n        return\n            frozenPermissionsHashed[\n                frozenPermissionHash(_where, _permissionId)\n            ];\n    }\n\n    /// @notice Grants the `ROOT_PERMISSION_ID` permission to the initial owner during initialization of the permission manager.\n    /// @param _initialOwner The initial owner of the permission manager.\n    function _initializePermissionManager(address _initialOwner) internal {\n        _grant(address(this), _initialOwner, ROOT_PERMISSION_ID);\n    }\n\n    /// @notice This method is used in the public `grant` method of the permission manager.\n    /// @param _where The address of the target contract for which `who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    function _grant(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) internal {\n        _grantWithOracle(\n            _where,\n            _who,\n            _permissionId,\n            IPermissionOracle(ALLOW_FLAG)\n        );\n    }\n\n    /// @notice This method is used in the internal `_grant` method of the permission manager.\n    /// @param _where The address of the target contract for which `who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _oracle The PermissionOracle to be used or it is just the ALLOW_FLAG.\n    function _grantWithOracle(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        IPermissionOracle _oracle\n    ) internal {\n        if (\n            _permissionId == ROOT_PERMISSION_ID &&\n            (_who == ANY_ADDR || _where == ANY_ADDR)\n        ) {\n            revert RootPermissionForAnyAddressDisallowed();\n        }\n\n        if (isFrozen(_where, _permissionId)) {\n            revert PermissionFrozen({\n                where: _where,\n                permissionId: _permissionId\n            });\n        }\n\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\n\n        if (permissionsHashed[permHash] != UNSET_FLAG) {\n            revert PermissionAlreadyGranted({\n                where: _where,\n                who: _who,\n                permissionId: _permissionId\n            });\n        }\n        permissionsHashed[permHash] = address(_oracle);\n\n        emit Granted(_permissionId, msg.sender, _who, _where, _oracle);\n    }\n\n    /// @notice This method is used in the public `revoke` method of the permission manager.\n    /// @param _where The address of the target contract for which `who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    function _revoke(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) internal {\n        if (isFrozen(_where, _permissionId)) {\n            revert PermissionFrozen({\n                where: _where,\n                permissionId: _permissionId\n            });\n        }\n\n        bytes32 permHash = permissionHash(_where, _who, _permissionId);\n        if (permissionsHashed[permHash] == UNSET_FLAG) {\n            revert PermissionAlreadyRevoked({\n                where: _where,\n                who: _who,\n                permissionId: _permissionId\n            });\n        }\n        permissionsHashed[permHash] = UNSET_FLAG;\n\n        emit Revoked(_permissionId, msg.sender, _who, _where);\n    }\n\n    /// @notice This method is used in the public `freeze` method of the permission manager.\n    /// @param _where The address of the target contract for which the permission is frozen.\n    /// @param _permissionId The permission identifier.\n    function _freeze(address _where, bytes32 _permissionId) internal {\n        if (_where == ANY_ADDR) {\n            revert FreezeOnAnyAddressDisallowed();\n        }\n\n        bytes32 frozenPermHash = frozenPermissionHash(_where, _permissionId);\n        if (frozenPermissionsHashed[frozenPermHash]) {\n            revert PermissionFrozen({\n                where: _where,\n                permissionId: _permissionId\n            });\n        }\n\n        frozenPermissionsHashed[frozenPermHash] = true;\n\n        emit Frozen(_permissionId, msg.sender, _where);\n    }\n\n    /// @notice Checks if a caller is granted permissions on a contract via a permission identifier and redirects the approval to an `PermissionOracle` if this was specified in the setup.\n    /// @param _where The address of the target contract for which `who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionOracle` registered..\n    /// @return bool Returns true if `who` has the permissions on the contract via the specified permissionId identifier.\n    function _isGranted(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) internal view returns (bool) {\n        address accessFlagOrAclOracle = permissionsHashed[\n            permissionHash(_where, _who, _permissionId)\n        ];\n\n        if (accessFlagOrAclOracle == UNSET_FLAG) return false;\n        if (accessFlagOrAclOracle == ALLOW_FLAG) return true;\n\n        // Since it's not a flag, assume it's an PermissionOracle and try-catch to skip failures\n        try\n            IPermissionOracle(accessFlagOrAclOracle).isGranted(\n                _where,\n                _who,\n                _permissionId,\n                _data\n            )\n        returns (bool allowed) {\n            if (allowed) return true;\n        } catch {}\n\n        return false;\n    }\n\n    /// @notice A private function to be used to check permissions on a target contract.\n    /// @param _where The address of the target contract for which the permission is required.\n    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.\n    function _auth(address _where, bytes32 _permissionId) private view {\n        if (\n            !(isGranted(_where, msg.sender, _permissionId, msg.data) ||\n                isGranted(address(this), msg.sender, _permissionId, msg.data))\n        )\n            revert Unauthorized({\n                here: address(this),\n                where: _where,\n                who: msg.sender,\n                permissionId: _permissionId\n            });\n    }\n\n    /// @notice Generates the hash for the `permissionsHashed` mapping obtained from the word \"PERMISSION\", the contract address, the address owning the permission, and the permission identifier.\n    /// @param _where The address of the target contract for which `who` recieves permission.\n    /// @param _who The address (EOA or contract) owning the permission.\n    /// @param _permissionId The permission identifier.\n    /// @return bytes32 The permission hash.\n    function permissionHash(\n        address _where,\n        address _who,\n        bytes32 _permissionId\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\"PERMISSION\", _who, _where, _permissionId)\n            );\n    }\n\n    /// @notice Generates the hash for the `frozenPermissionsHashed` mapping obtained from the word \"IMMUTABLE\", the contract address, and the permission identifier.\n    /// @param _where The address of the target contract for which `who` recieves permission.\n    /// @param _permissionId The permission identifier.\n    /// @return bytes32 The hash used in the `frozenPermissions` mapping.\n    function frozenPermissionHash(address _where, bytes32 _permissionId)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\"IMMUTABLE\", _where, _permissionId));\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[48] private __gap;\n}\n"
    },
    "contracts/lib/plugin/Plugin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport {DaoAuthorizable} from \"../dao-authorizable/DaoAuthorizable.sol\";\nimport {IDAO} from \"../interfaces/IDAO.sol\";\nimport {IPlugin} from \"../interfaces/IPlugin.sol\";\n\n/// @title Plugin\n/// @author Aragon Association - 2022\n/// @notice An abstract, non-upgradeable inherit from when creating a plugin being deployed via the `new` keyword.\nabstract contract Plugin is ERC165, IPlugin, DaoAuthorizable {\n    /// @notice Constructs the plugin by storing the associated DAO.\n    /// @param _dao The DAO contract.\n    constructor(IDAO _dao) DaoAuthorizable(_dao) {}\n\n    /// @inheritdoc IPlugin\n    function pluginType() public pure override returns (PluginType) {\n        return PluginType.Constructable;\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interace.\n    /// @return bool Returns true if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            _interfaceId == type(IPlugin).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}\n"
    },
    "contracts/lib/plugin/PluginCloneable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport {DaoAuthorizableCloneable} from \"../dao-authorizable/DaoAuthorizableCloneable.sol\";\nimport {IDAO} from \"../interfaces/IDAO.sol\";\nimport {IPlugin} from \"../interfaces/IPlugin.sol\";\n\n/// @title PluginCloneable\n/// @author Aragon Association - 2022\n/// @notice An abstract, non-upgradeable contract to inherit from when creating a plugin being deployed via the minimal clones pattern (see [ERC-1167](https://eips.ethereum.org/EIPS/eip-1167)).\nabstract contract PluginCloneable is ERC165, IPlugin, DaoAuthorizableCloneable {\n    /// @notice Initializes the plugin by storing the associated DAO.\n    /// @param _dao The DAO contract.\n    function __PluginCloneable_init(IDAO _dao)\n        internal\n        virtual\n        onlyInitializing\n    {\n        __DaoAuthorizableCloneable_init(_dao);\n    }\n\n    /// @inheritdoc IPlugin\n    function pluginType() public pure override returns (PluginType) {\n        return PluginType.Cloneable;\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interace.\n    /// @return bool Returns true if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            _interfaceId == type(IPlugin).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n}\n"
    },
    "contracts/lib/plugin/PluginSetup.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport {ERC1967Proxy} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {createERC1967Proxy as createERC1967} from \"../utils/Proxy.sol\";\nimport {IPluginSetup} from \"../interfaces/IPluginSetup.sol\";\n\nimport {PermissionLib} from \"../permission/PermissionLib.sol\";\n\n/// @title PluginSetup\n/// @author Aragon Association - 2022\n/// @notice An abstract contract that developers have to inherit from to write the setup of a plugin.\nabstract contract PluginSetup is ERC165, IPluginSetup {\n    /// @inheritdoc IPluginSetup\n    function prepareUpdateDataABI()\n        external\n        view\n        virtual\n        override\n        returns (string memory)\n    {}\n\n    /// @inheritdoc IPluginSetup\n    function prepareUpdate(\n        address _dao,\n        address _plugin,\n        address[] memory _currentHelpers,\n        uint16[3] calldata _oldVersion,\n        bytes memory _data\n    )\n        external\n        virtual\n        override\n        returns (\n            address[] memory updatedHelpers,\n            bytes memory initData,\n            PermissionLib.ItemMultiTarget[] memory permissions\n        )\n    {}\n\n    /// @notice A convenience function to create an [ERC-1967](https://eips.ethereum.org/EIPS/eip-1967) proxy contract pointing to an implementation and being associated to a DAO.\n    /// @param _implementation The address of the implementation contract to which the proxy is pointing to.\n    /// @param _data The data to initialize the storage of the proxy contract.\n    /// @return address The address of the created proxy contract.\n    function createERC1967Proxy(address _implementation, bytes memory _data)\n        internal\n        returns (address)\n    {\n        return createERC1967(_implementation, _data);\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param interfaceId The ID of the interace.\n    /// @return bool Returns true if the interface is supported.\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            interfaceId == type(IPluginSetup).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/lib/plugin/PluginUUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {UUPSUpgradeable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport {IERC1822ProxiableUpgradeable} from \"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\";\n\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {DaoAuthorizableUpgradeable} from \"../dao-authorizable/DaoAuthorizableUpgradeable.sol\";\nimport {IDAO} from \"../interfaces/IDAO.sol\";\nimport {IPlugin} from \"../interfaces/IPlugin.sol\";\n\n/// @title PluginUUPSUpgradeable\n/// @author Aragon Association - 2022\n/// @notice An abstract, upgradeable contract to inherit from when creating a plugin being deployed via the UUPS pattern (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\nabstract contract PluginUUPSUpgradeable is\n    IPlugin,\n    ERC165Upgradeable,\n    UUPSUpgradeable,\n    DaoAuthorizableUpgradeable\n{\n    // NOTE: When adding new state variables to the contract, the size of `_gap` has to be adapted below as well.\n\n    /// @inheritdoc IPlugin\n    function pluginType() public pure override returns (PluginType) {\n        return PluginType.UUPS;\n    }\n\n    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.\n    bytes32 public constant UPGRADE_PLUGIN_PERMISSION_ID =\n        keccak256(\"UPGRADE_PLUGIN_PERMISSION\");\n\n    /// @notice Initializes the plugin by storing the associated DAO.\n    /// @param _dao The DAO contract.\n    function __PluginUUPSUpgradeable_init(IDAO _dao)\n        internal\n        virtual\n        onlyInitializing\n    {\n        __DaoAuthorizableUpgradeable_init(_dao);\n    }\n\n    /// @notice Checks if an interface is supported by this or its parent contract.\n    /// @param _interfaceId The ID of the interace.\n    /// @return bool Returns true if the interface is supported.\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return\n            _interfaceId == type(IPlugin).interfaceId ||\n            _interfaceId == type(IERC1822ProxiableUpgradeable).interfaceId ||\n            super.supportsInterface(_interfaceId);\n    }\n\n    /// @notice Returns the address of the implementation contract in the [proxy storage slot](https://eips.ethereum.org/EIPS/eip-1967) slot the [UUPS proxy](https://eips.ethereum.org/EIPS/eip-1822) is pointing to.\n    /// @return implementation The address of the implementation contract.\n    function getImplementationAddress()\n        public\n        view\n        returns (address implementation)\n    {\n        implementation = _getImplementation();\n    }\n\n    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeabilty mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).\n    /// @dev The caller must have the `UPGRADE_PLUGIN_PERMISSION_ID` permission.\n    function _authorizeUpgrade(address)\n        internal\n        virtual\n        override\n        auth(UPGRADE_PLUGIN_PERMISSION_ID)\n    {}\n\n    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZepplins guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/lib/utils/auth.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport {IDAO} from \"../interfaces/IDAO.sol\";\n\n/// @notice Thrown if a call is unauthorized in the associated DAO.\n/// @param dao The associated DAO.\n/// @param here The context in which the authorization reverted.\n/// @param where The contract requiring the permission.\n/// @param who The address (EOA or contract) missing the permission.\n/// @param permissionId The permission identifier.\nerror DaoUnauthorized(\n    address dao,\n    address here,\n    address where,\n    address who,\n    bytes32 permissionId\n);\n\n/// @notice Free function to to be used by the auth modifier to check permissions on a target contract via the associated DAO.\n/// @param _permissionId The permission identifier.\nfunction _auth(\n    IDAO _dao,\n    address addressThis,\n    address _msgSender,\n    bytes32 _permissionId,\n    bytes calldata _msgData\n) view {\n    if (!_dao.hasPermission(addressThis, _msgSender, _permissionId, _msgData))\n        revert DaoUnauthorized({\n            dao: address(_dao),\n            here: addressThis,\n            where: addressThis,\n            who: _msgSender,\n            permissionId: _permissionId\n        });\n}\n"
    },
    "contracts/lib/utils/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/// @notice Free function to create a [ERC-1967](https://eips.ethereum.org/EIPS/eip-1967) proxy contract based on the passed base contract address.\n/// @param _logic The base contract address.\n/// @param _data The constructor arguments for this contract.\n/// @return address The address of the proxy contract created.\n/// @dev Initializes the upgradeable proxy with an initial implementation specified by _logic. If _data is non-empty, it’s used as data in a delegate call to _logic. This will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity constructor (see [OpenZepplin ERC1967Proxy-constructor](https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Proxy-constructor-address-bytes-)).\nfunction createERC1967Proxy(address _logic, bytes memory _data) returns (address) {\n    return address(new ERC1967Proxy(_logic, _data));\n}\n"
    },
    "contracts/lib/utils/TimeHelpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./Uint256Helpers.sol\";\n\ncontract TimeHelpers {\n    using Uint256Helpers for uint256;\n\n    /// @notice Gets the current block number.\n    /// @return The block number.\n    /// @dev Using a function rather than `block.number` allows us to easily mock the block number in tests.\n    function getBlockNumber() internal view virtual returns (uint256) {\n        return block.number;\n    }\n\n    /// @notice Gets the current block number converted to `uint64`.\n    /// @return The block number converted to `uint64`.\n    /// @dev Using a function rather than `block.number` allows us to easily mock the block number in tests.\n    function getBlockNumber64() internal view virtual returns (uint64) {\n        return getBlockNumber().toUint64();\n    }\n\n    /// @notice Gets the current timestamp.\n    /// @return The timestamp.\n    /// @dev Using a function rather than `block.timestamp` allows us to easily mock it in tests.\n    function getTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp; // solium-disable-line security/no-block-members\n    }\n\n    /// @notice Gets the current timestamp converted to `uint64`.\n    /// @return The timestamp converted to `uint64`.\n    /// @dev Using a function rather than `block.timestamp` allows us to easily mock it in tests.\n    function getTimestamp64() internal view virtual returns (uint64) {\n        return getTimestamp().toUint64();\n    }\n}\n"
    },
    "contracts/lib/utils/Uint256Helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nlibrary Uint256Helpers {\n    uint256 private constant MAX_UINT64 = type(uint64).max;\n\n    /// @notice Thrown if the checked value exceeds the a limit.\n    /// @param maxValue The maximum value.\n    /// @param value The compared value.\n    error OutOfBounds(uint256 maxValue, uint256 value);\n\n    /// @notice Casts a `uint256` safely to `uint64` making sure is not out of the bounds.\n    /// @param a The value to convert.\n    function toUint64(uint256 a) internal pure returns (uint64) {\n        if (a > MAX_UINT64) revert OutOfBounds({maxValue: MAX_UINT64, value: a});\n        return uint64(a);\n    }\n}\n"
    },
    "contracts/lib/utils/UncheckedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\n/// @notice Increments an unsigned integer by one without checking the result for overflow errors (using safe math).\n/// @param i The number to be incremented.\n/// @return The number incremented by one.\nfunction _uncheckedIncrement(uint256 i) pure returns (uint256) {\n    unchecked {\n        ++i;\n    }\n    return i;\n}\n\n/// @notice Add two unsigned integers without checking the result for overflow errors (using safe math).\n/// @param a The first summand.\n/// @param b The second summand.\n/// @return The sum.\nfunction _uncheckedAdd(uint256 a, uint256 b) pure returns (uint256) {\n    unchecked {\n        return a + b;\n    }\n}\n\n/// @notice Subtracts two unsigned integers without checking the result for overflow errors (using safe math).\n/// @param a The minuend.\n/// @param b The subtrahend.\n/// @return The difference.\nfunction _uncheckedSub(uint256 a, uint256 b) pure returns (uint256) {\n    unchecked {\n        return a - b;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}